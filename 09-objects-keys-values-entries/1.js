/* <div class="sc-bf073531-0 cSkfsr"><p>Создайте функцию, которая найдет в объекте всех людей, которым исполнилось 18 лет</p>
<p>Основные требования:</p>
<li>Функция с именем <code>getAdults</code> должна принимать объект вида <code>{ 'John Doe': 19, 'Tom': 17, 'Bob': 18 }</code>, где ключ - имя человека, значение - его возраст</li>
<li>Функция должна вернуть массив всех людей, кто старше 18 лет включительно</li>
<li>Для пустого объекта ф-ция должна вернуть пустой массив</li>
<li>Пример работы: <code>{ 'John Doe': 19, 'Tom': 17, 'Bob': 18 }</code> =&gt; <code>['John Doe', 'Bob']</code></li> */

const getAdults = (obj) =>
  Object.entries(obj)
    .filter((user) => user[1] >= 18)
    .map((user) => user[0]);
// put your code here

// <div class="sc-bf073531-0 cSkfsr"><p>Создайте функцию, которая будет копировать объект</p>
// <p>Основные требования:</p>
// <li>Функция с именем <code>copyObj</code> должна принимать объект и возвращать его копию (первого уровня)</li>
// <li>Исходный объект должен остаться неизменным</li>

const copyObj = (obj) => {
  return { ...obj };
};
// put your code here

// <div class="sc-bf073531-0 cSkfsr"><p>Напишем функцию, которая будет принять объект и выводить в консоль по очереди все свойства этого объекта</p>
// <h4>Основные требования:</h4>
// <li>Создай ф-цию <code>getKeys</code> в файле <code>index.js</code></li>
// <li>Ф-ция должна принимать объект как единственный аргумент и вывести в консоль название всех ключей этого объекта</li>
// <li>Для перебора ключей объекта используй метод <code>Object.keys</code></li>
// <li>Не используй цикл <code>for..in</code> - он может решить текущую задачу, но он устарел и в некоторых случаях может отработать не так, как ты того ожидаешь. Раньше мы смотрели его только для практики</li>
// <h4>Подсказки и типичные ошибки:</h4>
// <li>Выводить нужно не <b>массив</b> ключей, а каждый ключ <b>отдельно</b> с новой строки</li>

const getKeys = (obj) => Object.keys(obj).forEach((key) => console.log(key));

// Напиши 4 ф-ции, которые будут добавлять свойство в объект разным способом</p>
// <h4>Основные требования:</h4>
// <li>Все ф-ции должны быть в файле <code>index.js</code></li>
// <li>Все ф-ции принимают 2 аргумента: <code>userData</code> - объект пользователя и <code>userId</code> - строка - идентификатор пользователя</li>
// <li>Ф-ции должны добавить в объект пользователя свойство <code>id</code> со значением из второго аргумента ф-ции (<code>userId</code>)</li>
// <li>В ф-ции <code>addPropertyV1</code> просто используй оператор "точка" для добавления свойства объекта. Так ты изменишь исходный объект. Не забудь вернуть из ф-ции измененный объект</li>
// <li>В ф-ции <code>addPropertyV2</code> используй <code>Object.assign</code>. Так ты изменишь исходный объект. Не забудь вернуть из ф-ции измененный объект</li>
// <li>В ф-ции <code>addPropertyV3</code> используй <code>Object.assign</code>. Но используй его так, чтобы исходный объект не изменился. Здесь по сути нужно создать новый объект и не мутировать старый. Не забудь вернуть из ф-ции измененный объект</li>
// <li>В ф-ции <code>addPropertyV4</code> используй оператор расширения (spread operator). Исходный объект должен остаться неизменным. Не забудь вернуть из ф-ции измененный объект</li>
// <li>Как видишь, можно добавить свойство в исходный объект, а можно создать новый на основе старого и туда добавить еще одно свойство. На практике лучше не менять данные, которые приходят в аргументах ф-ции, а создать новые</li>
// <li>Смотри пример работы функции в редакторе</li>

/* eslint-disable prefer-object-spread */
/* eslint-disable no-param-reassign */

/* В решения этой задачи используется метод Object.assign. В реальных проектах для такой задачи
 * лучше использовать spread опертор - это самый современный подход
 *
 * Так же плохой подход - мутировать входящие параметры функции
 *
 * Задачу мы делаем для практики и демонстрационных целей, поэтому чтобы eslint не ругался на эту ошибку,
 * для этой задачи он отключен аннотацией eslint-disable
 * */

function addPropertyV1(userData, userId) {
  userData.id = userId;
  return userData;
}

const addPropertyV2 = (userData, userId) =>
  Object.assign(userData, { id: userId });

const addPropertyV3 = (userData, userId) =>
  Object.assign({}, userData, { id: userId });

const addPropertyV4 = (userData, userId) => {
  return { ...userData, id: userId };
};

// examples
const user = {
  name: "Sam",
};
addPropertyV1(user, "1234567"); // ==> { name: 'Sam', id: '1234567' }
